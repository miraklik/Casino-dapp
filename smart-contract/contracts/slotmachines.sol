// SPDX-License-Identifier: MIT
pragma solidity ^0.8.29;

import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./VipNFT.sol";


/**
 * @title SlotMachine Smart Contract
 * @notice A decentralized slot machine game with VIP NFT integration and Chainlink VRF random number generation.
 * @dev This contract allows users to place bets, receive winnings, and benefit from VIP NFT perks. 
 */
contract SlotMachine is VRFConsumerBaseV2, Ownable {
    VRFCoordinatorV2Interface public COORDINATOR;
    VipNFT public immutable vipNft;

    // Custom error messages for gas optimization
    error BetTooLow();
    error BetTooHigh();
    error CashBackFailed();
    error TransferFailed();
    error WithdrawFailed();
    error InsufficientBank();
    error NotEnoughFundsInHouseBank();
    error JackpotPayoutFailed();
    error MinimumBetMustBeLessThanMaximumBet();

    // Chainlink VRF parameters
    uint64 private immutable subscriptionId;
    address private immutable vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    bytes32 private immutable keyHash; //Insert your KEY_HASH 
    uint32 private constant callbackGasLimit = 200000;
    uint16 private constant requestConfirmations = 3;
    uint32 private constant numWords = 1;

    // Betting parameters
    uint256 public minBet = 0.0001 ether;
    uint256 public maxBet = 5 ether;
    uint256 public houseBank;
    uint256 public houseFee = 5;
    uint256 public jackpotPool;

    struct Game {
        address player;
        uint256 bet;
    }

    mapping(uint256 => Game) public games;

    // Events
    event SlotPlayed(address indexed player, uint256 amount, uint8[3] result, uint256 payout);
    event JackpotWon(address indexed winner, uint256 amount);
    event HouseBankUpdated(uint256 newBalance);

    /**
     * @notice Initializes the Roulette contract with Chainlink VRF and VIP NFT contract.
     * @param _subscriptionId Chainlink VRF subscription ID.
     */
    constructor(uint64 _subscriptionId, address _vipNFT) VRFConsumerBaseV2(vrfCoordinator) Ownable(msg.sender) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        subscriptionId = _subscriptionId;
        vipNft = VipNFT(_vipNFT);
    }

    /**
     * @notice Retrieves VIP benefits for a given player.
     * @param player The address of the player.
     * @return adjustedMaxBet Maximum bet limit based on VIP status.
     * @return adjustedHouseFee House fee percentage based on VIP status.
     * @return cashback Cashback percentage for the player.
     * @return winBonus Win multiplier bonus.
     */
    function getVipBenefits(address player) public view returns (uint256, uint256, uint256, uint256) {
        uint256 level = uint256(vipNft.getVipLevel(player));

        uint256 adjustedMaxBet = maxBet;
        uint256 adjustedHouseFee = houseFee;
        uint256 cashback = 0;
        uint256 winBonus = 0;

        if (level == uint256(VipNFT.VipLevel.SILVER)) {
            adjustedMaxBet += 2 ether;
            adjustedHouseFee = 3;
            cashback = 2;
            winBonus = 5;
        } else if (level == uint256(VipNFT.VipLevel.GOLD)) {
            adjustedMaxBet += 5 ether;
            adjustedHouseFee = 2;
            cashback = 5;
            winBonus = 10;
        } else if (level == uint256(VipNFT.VipLevel.PLATINUM)) {
            adjustedMaxBet += 10 ether;
            adjustedHouseFee = 1;
            cashback = 10;
            winBonus = 20;
        }

        return (adjustedMaxBet, adjustedHouseFee, cashback, winBonus);
    }

    /**
    * @notice Plays the slot machine game using msg.value as the bet.
    */
     function playSlot() external payable {
        (uint256 adjustedMaxBet, uint256 adjustedHouseFee, uint256 cashback, ) = getVipBenefits(msg.sender);

        if (msg.value < minBet) revert BetTooLow();
        if (msg.value > adjustedMaxBet) revert BetTooHigh();

        uint256 jackpotPart = (msg.value * 1) / 100;
        jackpotPool += jackpotPart;

        uint256 feeAmount = (msg.value * adjustedHouseFee) / 100;
        houseBank += feeAmount;
        uint256 betAmount = msg.value - feeAmount - jackpotPart;

        if (cashback > 0) {
            uint256 cashbackAmount = (msg.value * cashback) / 100;
            (bool success, ) = payable(msg.sender).call{value: cashbackAmount}("");
            if (!success) revert CashBackFailed();
        }

        uint256 requestId = COORDINATOR.requestRandomWords(
            keyHash, subscriptionId, requestConfirmations, callbackGasLimit, numWords
        );


        games[requestId] = Game(msg.sender, betAmount);
        emit HouseBankUpdated(houseBank);
    }

    /**
     * @notice Processes the random number generated by Chainlink VRF.
     * @param requestId The request ID.
     * @param randomWords The random number generated by Chainlink VRF.
     */
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
        Game memory game = games[requestId];
        delete games[requestId];

        uint8[3] memory slots;
        for (uint8 i = 0; i < 3; i++) {
            slots[i] = uint8((randomWords[i] % 6) + 1); // Symbols: 1 to 6
        }

        (, , , uint256 winBonus) = getVipBenefits(game.player);

        uint256 payout = calculatePayout(slots, game.bet, winBonus);

        uint256 jackpotChance = randomWords[0] % 1000;
        if (jackpotChance == 777 && jackpotPool > 0) {
            (bool success, ) = payable(game.player).call{value: jackpotPool}("");
            require(success, JackpotPayoutFailed());
            emit JackpotWon(game.player, jackpotPool);
            jackpotPool = 0;
        }

        if (payout > 0) {
            if (payout > houseBank) revert NotEnoughFundsInHouseBank();

            (bool success, ) = payable(game.player).call{value: payout}("");
            if (!success) revert TransferFailed();

            houseBank -= payout;
        }

        emit SlotPlayed(game.player, game.bet, slots, payout);
        emit JackpotWon(game.player, game.bet);
        emit HouseBankUpdated(houseBank);
    }

    /**
     * @notice Calculates the payout based on the symbols in the slots.
     * @param slots The symbols in the slots.
     * @param bet The amount of ETH bet.
     * @return The payout amount.
     */
    function calculatePayout(uint8[3] memory slots, uint256 bet, uint256 winBonus) internal pure returns (uint256) {
        uint256 multiplier = 0;

        if (slots[0] == slots[1] && slots[1] == slots[2]) {
            multiplier = 10;
        } else if (slots[0] == slots[1] || slots[1] == slots[2] || slots[0] == slots[2]) {
            multiplier = 2;
        }

        if (multiplier == 0) return 0;

        uint256 basePayout = bet * multiplier;
        uint256 bonus = (basePayout * winBonus) / 100;
        return basePayout + bonus;
    }


    /**
     * @notice Sets the minimum and maximum bet limits.
     * @param _min The minimum bet limit.
     * @param _max The maximum bet limit.
     */
    function SetLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min < _max, MinimumBetMustBeLessThanMaximumBet());
        minBet = _min;
        maxBet = _max;
    }

    function withdraw(address payable _to, uint256 amount) external onlyOwner {
        require(amount <= houseBank, InsufficientBank());
        houseBank -= amount;
        (bool success, ) = _to.call{value: amount}("");
        require(success, WithdrawFailed());
        emit HouseBankUpdated(houseBank);
    }

    receive() external payable {
        houseBank += msg.value;
        emit HouseBankUpdated(houseBank);
    }
}

